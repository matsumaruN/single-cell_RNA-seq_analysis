---
title: "Seurat_Tutorial"
author: "Naoki Matsumaru"
date: "2024-04-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown


https://note.com/tokitky/n/n7a72fae06ade?magazine_key=mf2b7c75acd21
https://kero.hgc.jp/open_tutorials/learning/contents/single2_article.html

```{r}
library(edgeR)
library(made4)
library(fgsea)
library(genefilter)
library(caret)
library(pheatmap)
library(RColorBrewer)
library(ggplot2)
library(gplots)
library(calibrate)
#library(maptools)
library(FactoMineR)
library(rgl)
library(BBmisc)
library(survival)
library(survminer)
library(dplyr)
library(stringr)
library(data.table)
library(reshape2)
library(beeswarm)
library(Seurat)
library(cowplot)
#library(SeuratData)

```

```{r}
D000.data <- read.table(file.path("dat_AML371","GSM3587946_AML371-D0.dem.txt"), header=T, row.names=1, check.names = T, sep="\t")
D034.data <- read.table(file.path("dat_AML371","GSM3587948_AML371-D34.dem.txt"), header=T, row.names=1, check.names = T, sep="\t")
```

```{r}
D000.anno <- read.table(file.path("dat_AML371", "GSM3587947_AML371-D0.anno.txt"), header=T, row.names=1, sep="\t");
D034.anno <- read.table(file.path("dat_AML371", "GSM3587949_AML371-D34.anno.txt"), header=T, row.names=1, sep="\t");
```


```{r}
D000.data %>% filter(str_detect(row.names(.), "^MT-"))
```

```{r}
print(D034.anno)
```

```{r}
D000 <- CreateSeuratObject(D000.data, project="AML371", min.cell=0)
D034 <- CreateSeuratObject(D034.data, project="AML371", min.cell=3)
```
```{r}
print(D000)
```
```{r}
D000@meta.data$stim <- "D000"
D034@meta.data$stim <- "D034"
```

```{r}
D000@meta.data$mal <- D000.anno$PredictionRF2
D034@meta.data$mal <- D034.anno$PredictionRF2

D000@meta.data$mal
D034@meta.data$mal
```

```{r}
print(D000@meta.data)
```
```{r}
D000
```


```{r}
#QC check
D000[["percent.mt"]] <- PercentageFeatureSet(D000, pattern="^MT-")
D034[["percent.mt"]] <- PercentageFeatureSet(D034, pattern="^MT-")
```

```{r}
D000[["percent.mt"]]
```

```{r}
a <- D000.data %>% filter(str_detect(row.names(.), "^MT-")) %>% select(ends_with("AAAGCAGTTATT")) %>% sum
b <- D000.data %>% select(ends_with("AAAGCAGTTATT")) %>% sum
 a / (b)
 b

a <- D000.data %>% filter(str_detect(row.names(.), "^MT-")) %>% select(ends_with("AAGAAAGTGCCA")) %>% sum
b <- D000.data %>% select(ends_with("AAGAAAGTGCCA")) %>% sum
a / (b-a)
D000.data %>% filter(str_detect(row.names(.), "^MT-")) %>% select(ends_with("AAGGCCGAGTCA")) %>% sum / D000.data %>% select(ends_with("AAGGCCGAGTCA")) %>% sum
D000.data %>% filter(str_detect(row.names(.), "^MT-")) %>% select(ends_with("AAGTAAAGGGTN")) %>% sum / D000.data %>% select(ends_with("AAGTAAAGGGTN")) %>% sum
D000.data %>% filter(str_detect(row.names(.), "^MT-")) %>% select(ends_with("AGACTTTGAGTN")) %>% sum / D000.data %>% select(ends_with("AGACTTTGAGTN")) %>% sum
```
```{r}
D000[["nFeature_RNA"]]
```

```{r, fig.width=13,fig.height=5}
v1 <- VlnPlot(D000, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
v2 <- VlnPlot(D034, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

plot_grid(v1, v2)
```

```{r}
D000@meta.data
D000.data %>% select(ends_with("AAAGCAGTTATT")) %>% sum
D000.data %>% select(ends_with("AAAGCAGTTATT")) %>% filter(AML371.D0_AAAGCAGTTATT!=0) %>% count
```

```{r, eval=FALSE}
D000 <- subset(D000, subset = nFeature_RNA > 200 & nFeature_RNA < 2000 & percent.mt < 5)
D034 <- subset(D034, subset = nFeature_RNA > 200 & nFeature_RNA < 3000 & percent.mt < 5)

```

```{r, fig.width=13,fig.height=5}
v1 <- VlnPlot(D000, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
v2 <- VlnPlot(D034, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

plot_grid(v1, v2)
```



```{r}
#normalize
D000 <- NormalizeData(D000, normalization.method = "LogNormalize", scale.factor = 10000)
D034 <- NormalizeData(D034, normalization.method = "LogNormalize", scale.factor = 10000)
```

```{r, fig.width=13, fig.height=5}

v1 <- VlnPlot(D000, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
v2 <- VlnPlot(D034, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

plot_grid(v1, v2)
```

```{r, fig.width=12, fig.height=5}
p1 <- FeatureScatter(D000, feature1 = "nCount_RNA", feature2 = "percent.mt")
p2 <- FeatureScatter(D034, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

plot_grid(p1, p2)
```


```{r}
#feature selection
D000 <- FindVariableFeatures(D000, selection.method = "vst", nfeatures = 3000)
D034  <- FindVariableFeatures(D034, selection.method = "vst", nfeatures = 3000)
```

```{r}
top10 <- head(VariableFeatures(D000),10)
top10
```

```{r, fig.width=13, fig.height=4}
plot1 <- VariableFeaturePlot(D000)
plot1l <- LabelPoints(plot=plot1, points = top10, repel=TRUE)
plot2 <- VariableFeaturePlot(D034)
plot_grid(plot1l, plot2)
```

```{r}
mm <- D000.data %>% filter(str_detect(row.names(.),"ELANE")) %>% transpose %>% unlist() %>% as.vector('numeric') %>% mean
vv <- D000.data %>% filter(str_detect(row.names(.),"ELANE")) %>% transpose %>% unlist() %>% as.vector('numeric') %>% var
mm %>% log10
vv %>% log10
```

```{r}
HVFInfo(D000)
HVFInfo(D000) %>% ggplot(mapping=aes(x=mean, y=variance))+scale_x_log10() + scale_y_log10()+ geom_point() +geom_smooth(method="loess",span=0.3)
```

https://github.com/satijalab/seurat/issues/3946

https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8

Feature selection for individual datasets
In each dataset, we next aimed to identify a subset of features (e.g., genes) exhibiting high variability across cells, and therefore represent heterogeneous features to prioritize for downstream analysis. Choosing genes solely based on their log-normalized single-cell variance fails to account for the mean-variance relationship that is inherent to single-cell RNA-seq. Therefore, we first applied a variance-stabilizing transformation to correct for this [Mayer et al., 2018, Hafemeister and Satija, 2019].
To learn the mean-variance relationship from the data, we computed the mean and variance of each gene using the unnormalized data (i.e., UMI or counts matrix), and applied  log10
 -transformation to both. We then fit a curve to predict the variance of each gene as a function of its mean, by calculating a local fitting of polynomials of degree 2 (R function loess, span = 0.3). This global fit provided us with a regularized estimator of variance given the mean of a feature. As such, we could use it to standardize feature counts without removing higher-than-expected variation.
Given the expected variances, we performed the transformation
zij=xij−x¯iσi,
 


where  zij
  is the standardized value of feature i in cell j,  xij
  is the raw value of feature i in cell j,  x¯i
  is the mean raw value for feature i, and  σi
  is the expected standard deviation of feature i derived from the global mean-variance fit. To reduce the impact of technical outliers, we clipped the standardized values to a maximum value of  N−−√
 , where N is the total number of cells. For each gene, we then computed the variance of standardized values across all cells. This variance represents a measure of single-cell dispersion after controlling for mean expression, and we use it directly to rank the features. Unless otherwise noted, we selected the 2,000 genes with the highest standardized variance as “highly variable.” This procedure is implemented in the FindVariableFeatures function in Seurat v3 (selection.method = “vst”).
 
 https://www.biostars.org/p/9504440/
 
 #Scaling
 
```{r}
all.genes.000 <- rownames(D000)
all.genes.034 <- rownames(D034)
D000 <- ScaleData(D000, features=all.genes.000)
D034 <- ScaleData(D034, features=all.genes.034)
```
```{r, fig.width=12,fig.height=5}
#D000[["RNA"]]$scale.data %>% mean()
#D000[["RNA"]]$scale.data %>% var()
D000[["RNA"]]$scale.data %>% as.data.frame()　%>% unlist %>% as.numeric %>% var
```
```{r}
#D000[["RNA"]]$scale.data
D000 %>% names
D000@reductions
D000@meta.data
```


# PCA による次元削減

```{r}
D000 <- RunPCA(D000, features = head(VariableFeatures(object=D000), 100000))
```
 
```{r}
print(D000[["pca"]], dims=1:3, nfeatures=5)
```

```{r, fig.height=6}
VizDimLoadings(D000, dims=1:2, reduction="pca")
```


```{r}
#integration of Data

AML371_all.list <- NULL
AML371_all.list <- list(D000, D034)

names(AML371_all.list) <- c("D000","D034")
AML371_all.list 

AML371_all.anchors <- FindIntegrationAnchors(object.list = AML371_all.list, dims = 1:30)
AML371_all.integrated <- IntegrateData(anchorset = AML371_all.anchors, dims = 1:30)
DefaultAssay(AML371_all.integrated) <- "integrated"
```

```{r}
AML371_all.integrated <- ScaleData(AML371_all.integrated, verbose = FALSE)
AML371_all.integrated <- RunPCA(AML371_all.integrated , npcs = 30, verbose = FALSE)
AML371_all.integrated <- RunUMAP(AML371_all.integrated , reduction = "pca", dims = 1:5)
AML371_all.integrated  <- FindNeighbors(AML371_all.integrated , reduction = "pca", dims = 1:5)
AML371_all.integrated  <- FindClusters(AML371_all.integrated , resolution = 0.5)
p1 <- DimPlot(AML371_all.integrated , reduction = "umap", group.by = "stim")
p2 <- DimPlot(AML371_all.integrated , reduction = "umap", group.by = "mal")
p3 <- DimPlot(AML371_all.integrated , reduction = "umap",label = TRUE,
             repel = TRUE) + NoLegend()
plot_grid(p1, p2, p3)
```

```{r}
v1 <- DimPlot(AML371_all.integrated , reduction = "umap", label = TRUE, split.by="stim")
v2 <- DimPlot(AML371_all.integrated , reduction = "umap", label = TRUE, split.by="mal")
v3 <- DimPlot(AML371_all.integrated , reduction = "umap", group.by="stim", split.by="mal")
v4 <- DimPlot(AML371_all.integrated , reduction = "umap", group.by="mal", split.by="stim")
plot_grid(v1, v2, v4, v3)
```
```{r}
AML371_all.integrated$mal.stim <- paste(AML371_all.integrated$mal, AML371_all.integrated$stim, sep = "_")
AML371_all.integrated$mal.stim 
```


```{r}
#Before and after in leukemia
mal.chemo.response <- FindMarkers(AML371_all.integrated, ident.1 = "malignant_D034", ident.2 = "malignant_D000", verbose = FALSE)
#Before and after in Normal
normal.chemo.response <- FindMarkers(AML371_all.integrated, ident.1 = "normal_D034", ident.2 = "normal_D000", verbose = FALSE)
```

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
